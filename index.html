<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emotion-based Spotify Playlist</title>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
</head>
<body>
<div class="container mt-5">
  <h1>Generate Playlist by Emotion</h1>
  <p>Select an emotion to create a Spotify playlist:</p>
  <select id="emotionSelect" class="form-control mb-3">
    <option value="Happy">Happy</option>
    <option value="Sad">Sad</option>
    <option value="Relaxed">Relaxed</option>
    <option value="Excited">Excited</option>
    <option value="Angry">Angry</option>
    <option value="Calm">Calm</option>
  </select>
  <button id="generateBtn" class="btn btn-primary">Generate Playlist</button>
  <div id="playlistLink" class="mt-3"></div>
</div>

<script>
  const emotionMap = {
    Happy: { valence: 0.8, energy: 0.7, danceability: 0.8, genres: ["pop", "dance", "funk"] },
    Sad: { valence: 0.2, energy: 0.3, danceability: 0.3, genres: ["acoustic", "indie", "piano"] },
    Relaxed: { valence: 0.7, energy: 0.3, danceability: 0.4, genres: ["chill", "ambient", "jazz"] },
    Excited: { valence: 0.8, energy: 0.9, danceability: 0.8, genres: ["edm", "pop", "rock"] },
    Angry: { valence: 0.3, energy: 0.9, danceability: 0.5, genres: ["metal", "punk", "hard-rock"] },
    Calm: { valence: 0.6, energy: 0.3, danceability: 0.4, genres: ["classical", "ambient", "jazz"] }
  };

  const clientId = "4da5a5ff08664ff9bc5aa87dcc2e1728";
  const clientSecret = "a142799b960b4172956135d5d5e03cd4";
  let accessToken;

  // Fetch Spotify access token
  async function fetchAccessToken() {
    const response = await fetch("https://accounts.spotify.com/api/token", {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "Authorization": "Basic " + btoa(clientId + ":" + clientSecret)
      },
      body: "grant_type=client_credentials"
    });

    const data = await response.json();
    accessToken = data.access_token;
  }

  async function getRecommendations(emotion) {
    const features = emotionMap[emotion];
    const params = new URLSearchParams({
      seed_genres: features.genres.join(','),
      target_valence: features.valence,
      target_energy: features.energy,
      target_danceability: features.danceability,
      limit: 10
    });

    try {
      const response = await fetch(`https://api.spotify.com/v1/recommendations?${params}`, {
        headers: { 'Authorization': `Bearer ${accessToken}` }
      });

      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After');
        console.log(`Rate limited. Retrying in ${retryAfter} seconds...`);
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        return getRecommendations(emotion); // Retry after waiting
      }

      if (!response.ok) throw new Error('Failed to fetch recommendations');

      const data = await response.json();
      return data.tracks.map(track => track.uri);
    } catch (error) {
      console.error(error);
      return [];
    }
  }

  async function createPlaylist(emotion, trackUris) {
    try {
      // Create a new playlist
      const playlistResponse = await fetch(`https://api.spotify.com/v1/users/${userId}/playlists`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          name: `${emotion} Playlist`,
          description: `A playlist inspired by feeling ${emotion}`,
          public: true
        })
      });

      if (!playlistResponse.ok) throw new Error('Failed to create playlist');

      const playlistData = await playlistResponse.json();

      // Add tracks to the new playlist
      const addTracksResponse = await fetch(`https://api.spotify.com/v1/playlists/${playlistData.id}/tracks`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ uris: trackUris })
      });

      if (!addTracksResponse.ok) throw new Error('Failed to add tracks to playlist');

      return playlistData.external_urls.spotify;
    } catch (error) {
      console.error(error);
      return null;
    }
  }

  document.getElementById('generateBtn').addEventListener('click', async () => {
    const emotion = document.getElementById('emotionSelect').value;
    const trackUris = await getRecommendations(emotion);

    if (trackUris.length === 0) {
      document.getElementById('playlistLink').innerHTML = '<p class="text-danger">Failed to generate playlist.</p>';
      return;
    }

    const playlistUrl = await createPlaylist(emotion, trackUris);
    if (playlistUrl) {
      document.getElementById('playlistLink').innerHTML = `<a href="${playlistUrl}" target="_blank" class="btn btn-success">Open ${emotion} Playlist</a>`;
    } else {
      document.getElementById('playlistLink').innerHTML = '<p class="text-danger">Failed to create playlist.</p>';
    }
  });
</script>
</body>
</html>
